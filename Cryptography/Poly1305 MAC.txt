"poly1305" (defined in RFC 7539) is a message authenticator. The name is sometimes written with a capitalized first letter.

It calculates a message authentication code (MAC) over a message of arbitrary size. It requires a nonce and a secret authentication key for calculation and verification.

A "nonce" is an arbitrary and not necessarily secret value used for authenticating/verifying only one particular instance of message contents. It must NEVER be used again (with the same key) for a message with different contents, not even after many years!

The poly1305 nonce and authentication key are combined as a 256 bit authentication parameter. The bits of this parameter can be structured in 3 different ways:

* A 234 bit secret nonce (which also serves as the authentication key).

* A 106 bit (possibly non-secret) nonce "r" and a 128 bit secret authentication key "s" (which may be used any number of times).

* A 106 bit (possibly non-secret) constant "r" and a 128 bit secret nonce "s" (which also serves as the authentication key).

In all cases, the 256 parameter bits are split in two halves "r" (the first half) and "s" (the second one). "r" contains 22 unused bits which will be set to "0" by the algorithm automatically. (Which bits of "r" are unused is defined by the constant "clamp", see below.)

The pair ("r", "s") MUST be unpredictable and SHOULD be unique for every message, but "r" MAY be a publicly known constant or a non-secret nonce.

In other words, "s" must be a secret nonce if "r" is a constant, or "s" can be an arbitrary secret if "r" is a nonce.

Author's comment 2018-08: I have *severe* doubts about non-secret values for "r", because the actual MAC calculation only depends on "r" and the message contents. "s" is only added to the intermediate result in the very last step. Knowing "r" and the message contents, it must therefore be trivial to calculate "s". In my opinion, "r" may be a constant or a simple counter value with a constant offset value, but an attacker must not be able to guess "r".

The most common way to derive to both "r" and "s" seems to be deriving a pseudo-random 256-bit sequence from a MAC key first and then binary-AND the "r"-subvalue with the "clamp" constant defined below.

The 128-bit constant "clamp" contains 4 * 4 + 3 * 2 (= 22) '0'-bits and has the following numeric value (in ISO C syntax):

0x\
0ffffffc\
0ffffffc\
0ffffffc\
0fffffff

Hint for remembering: When written as a hex number from left to right as 4 groups of smaller 8-digit hex numbers, start with all digits filled as 'F'. Then set the first digit of all numbers to '0' (clearing the 4 most significant bits) and set the last digit of all numbers except the last one to 'C' (clearing the 2 least significant bits).

All arithmetic is done on arbitrary-length integers which are read from or written to buffers in little-endian byte order (least significant to most significant). When implementing modular multiplication as a combined operation, 130-bit unsigned integers will suffice for all calculations.

"r" and "s" are also interpreted as such, as is the variable "mac" which will eventually represent the resulting MAC.

Then we need a helper function read_int128_le() which reads the input stream in units of 16 octets (the last block may be shorter), interprets them as a 128-bit number in little-endian byte order, and returns that number as well as the number of bits which were actually read. (The latter being a number from 0 to 128 which is a multiple of 8. A value of 0 also means that the end of the stream has been reached).

The actual poly1305 algorithm works as follows:

function poly1305_mac(r, s, input_stream)
	r:= bitwise_and(r, clamp);
	mac:= 0;
	forever
		(unit, num_bits_read):= read_int128_le(input_stream);
		if num_bits_read == 0 then
			return (mac + s) modulo 2**128;
		end if
		unit:= unit + 2**num_bits_read;
		mac:= ((mac + unit) * r) modulo (2**130 - 5);
	repeat
end

The addition, multiplication and exponentiation operations used by this algorithm are normal mathemathical operators, not "polynomial arithmetic", "interval arithmetic" or something like that.

The name of the algorithm comes from the constant 2**130 - 5 (a prime number). This number has all bits set to "1" except for the third rightmost bit.

Note that as a consequence of the algorithm design, a (clamped) "r" of 0 will always return "s" unmodified as the MAC, and an authentication parameter with all bits "0" will always return a MAC with all bits "0".

Therefore, avoid authentication parameters with too few "1" bits. They should best have been generated by some pseudo-random function from other key material, thus looking "random" with approximately the same amount of "0" and "1" bits.

The only expensive operation of poly1305 is the modular multiplication x * r modulo p.

Other MACs like CBC-MAC may seem simpler than poly1305 at a first glance, but they normally invoke an underlying block cipher which is typically more expensive than a modular multiplication.

poly1305 test vector (from the RFC):

Key:
85 d6 be 78 57 55 6d 33 7f 44 52 fe 42 d5 06 a8
01 03 80 8a fb 0d b2 fd 4a bf f6 af 41 49 f5 1b

Message (ASCII w/o the quotes): "Cryptographic Forum Research Group"

Resulting MAC: a8 06 1d c1 30 51 36 c6 c2 2b 8b af 0c 01 27 a9
