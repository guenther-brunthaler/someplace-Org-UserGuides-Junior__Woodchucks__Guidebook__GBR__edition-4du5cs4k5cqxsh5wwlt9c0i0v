Things to know when using systemd
=================================
v2021.78


Important terms in `systemd` context
------------------------------------

The following terms must be known in order to understand most of the `systemd` documentation and discussion:

daemon:: `systemd` stands for "system daemon", and 'daemon' (note the 'a' as part of the spelling) is a UNIX acronym for 'disk and execution monitor'. This term is meant to describe an autonomously running background program which is not related to a particular user but rather part of the system itself. Daemons monitor certain changes of the current system state and react to it somehow. For instance, the traditional `syslogd` waits for system-wide log messages sent by running processes via the 'syslog()' API, filters and reformats them, and finally appends them to some log file in `/var/log`. A different well known daemon is 'cron' which runs programs performing periodic maintainance tasks (such as logfile rotation) at specific intervals.

service:: This refers to the traditional `/etc/init.d/*`- and `/etc/rc?.d/*`-files. A service represents either a 'daemon' or a system state that can be 'started' and 'stopped' like a 'daemon', except that the state is not represented by a 'daemon' but rather by some other type of resource, such as the existence of some ephemeral directory in `/run` which is required by other services.

unit:: `systemd` does not just support services but other units of management, too. `unit` is a collective name for all those types of services. After a 'unit' has been started, its resulting dynamic runtime configuration can be shown with +systemctl show 'UNIT_NAME'+ which gives a long list of values and is generally not very helpful for a quick examination of the unit status. Instead, +systemctl status 'UNIT_NAME'+ should be used to get a quick summary of the most important runtime-properties of a 'unit', such as whether it is currently active/running or not.

template units:: Some units are autogenerated after startup by instantiating template units. For instance, there are different units for each `agetty` listening on a particular 'tty', but all of them are based on the same template unit. Template units and units instantiated based on them can be recognized by the "@"-sign present as part of their names. Most of the time it is pointless to try customizing an autogenerated unit. Instead, the template unit should be customized on which the autogenerated units will be based on.

unit file:: Most 'units' have a definition file which defines the unit and its behaviour. Those files can be displayed with +systemctl cat 'UNIT_NAME'+. When requesting to show the unit file for a unit based on a template, the unit file for the template will be shown instead, because there are no unit files for individual template instantiations. Actually, there seem to be unit files for instantiated units, but they are just symlinks to the template unit files the units are based on. In other cases no unit files are required, because there are defaults for unit properties and sometimes those are sufficient. In such cases, there is a symlink to `/dev/null` instead of a unit file of the same name.

socket:: This is a type of `systemd` 'unit' which roughly equates to a definition entry in '/etc/inetd.conf' on traditional systems. 'socket units' can replace the traditional `inetd` daemon.

socket activation:: When 'socket units' are active, `systemd` opens communication sockets instead of the 'service' which would otherwise listen on that socket, and waits until someone actually tries to connect to this socket. Then systemd starts the 'service' which shall actually handle that socket, and passes the already-opened socket to it for actual processing. The purpose of 'socket units' is therefore to avoid that all services which need to listen on some port need to run permanently. They are started automatically on-demand by `systemd`.

timer:: This type of `systemd` 'unit' roughly equates to a 'cron job'. It represents actions to be performed either periodically or once at a particular date and time. 'timer units' can be used to replace the traditional `cron`, `anacron` and `at` daemons. There is in fact a package ("'systemd-cron'" on 'Debian') which does exactly that.

target:: This is a type of `systemd unit` which most closely equates to 'runlevels' of traditional systems. Every target is a collection of services which are defined to be part of it. Different than runlevels, targets are identified by names rather than numbers and can be nested. This allows to include the same named sub-targets in multiple higher-level targets.

slice:: Slice units group available resources and defined resource restrictions into hierarchical tree structures and allow to assign the resulting collection of resources to a service or scope unit. Slices use Linux kernel features such as 'cgroups' and 'namespaces' for enforcing the defined grouping.

scope:: Scope units allow to group related processes into a organizational container and then control aspects of all the contained processes via the scope unit. Typically, a slice unit will define some resource restrictions, and will be assigned to a scope unit consisting of a set of several services which will then all be subject to those same resource restrictions.


General
-------

* In systemd one has to press eight times `[Ctrl]+[Alt]+[Del]` in order to trigger a reboot. At least under some condition. (Maybe in a GUI session?) In the virtual consoles, a single instance of this key combination is sufficient. (At least on Debian.)

* Every machine has a unique file `/etc/machine-id`. This ID must also be kept secret (outside of the machine, such as on the network - every local user can show it). A tweaked/personalized hash of it can be used to create persistent machine-unique public identifiers, though. When the file is truncated, a new machine-ID will be generated and written to it at the next reboot. Use this after cloning an installation to ensure unique machine-IDs in the clone.

* A systemd service may clean some directories at startup, shutdown and also regularly during uptime, optionally based on item age, such as `/tmp` and `/var/tmp`. This means files created there may be deleted automatically without any warning after some time. `systemd-tmpfiles --cat-config` shows the configuration of the cleaning setup. Be sure to check this in order to avoid bad surprises when your files get deleted automatically. It is also possible to disable selected entries by overriding them.

* `$SHELL` might not contain an absolute path, but just a program name such as `bash`. I am not sure whether this might actually be POSIX compliant, but I have never encountered this on non-`systemd` based installations. On most other types of installation `$SHELL` contains one of the lines in file `/etc/shells` (which always contains absolute paths).

* Units for which the definition files have been removed may remain in a "dead" state, especially timer units. The can be stopped, but cannot be deleted. The solution is to invoke the "reset-failed" command for those units.

* At least Debian has an installed `dphys-swapfile.service` which sets up and activated an unencrypted swap file as /var/swap. This is done without consulting the administrator first. This is extremely dangerous in the case of multiple-encryption layers, because then date encrypted more securely than `/var` might end up in `/var/swap`, potentially destroying all security of the additional encryption layers. As a rule of thumb, the swap must be encrypted as least as many times as the deepest nested encryption layer, and also with at least the same security parameters.


Fix logging
-----------

If the message

....
logger: socket /dev/log: Connection refused
....

appears, do the following:

----
$ systemctl stop \
     systemd-journald \
     systemd-journald-audit.socket \
     systemd-journald-dev-log.socket \
     systemd-journald.socket \
  && rm /dev/log \
  && systemctl start systemd-journald
----

This is frequently necessary after running a `systemd`-installation within a Root Jail.


Runlevels
---------

`systemd`\'s 'runlevels' are not identified by numbers like on traditional systems, but rather defined by certain named 'targets', not unlike in 'Gentoo Linux'. Usually at least those targets are available:

----
$ systemctl isolate graphical # telinit 5
$ systemctl isolate multi-user # telinit 2, 3 or 4
----

This switches between the most important runlevels, the one with a graphical login and the one only with text consoles for login.

Not all targets can be used as arguments for the 'isolate' sub-command. Targets which are allowed to be used as "runlevels" must have their boolean `AllowIsolate`-property enabled.

The default runlevel which can be displayed on a traditional system like this

----
$ grep '^[^:]*:[^:]*:initdefault:' /etc/inittab
id:4:initdefault:
----

can be viewed on a `systemd`-system like that:

----
$ ls -log /etc/systemd/system/default.target
lrwxrwxrwx 1 37 Mär  5 02:35 /etc/systemd/system/default.target -> /lib/systemd/system/multi-user.target
----

For compatibility with traditional systems, there are special target names like `runlevel5.target` which can be aliased with other named targets. Then a traditional command invocation like `telinit 5` will be emulated by `systemd` in order to switch to ('isolate' in `systemd` parlance) this target.


Assigning services to certain runlevels only
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The purpose of runlevels is that services (or other systemd units like sockets used for service activation) are running/active only in certain runlevels.

First of all, 'unit files' can define a `WantedBy`-key in their '[Install]'-sections. This defines the "default runlevels" in which this unit shall be active, i. e. a list of 'target units' this unit should be made a part of when the unit file is loaded by `systemd`.

A quick way to see which units have been assigned to which runlevels is to look into the

----
$ ls /etc/systemd/system/*.target.wants/*
----

directories. Every such `*.target.wants` directory contains symlinks to all unit files which are currently assigned to the 'runlevel' represented by that 'target', or symlinks to other 'targets' which are recursively "included" by this target.

Some of the symlinks may point to non-existing unit files. In this case the dead symlinks will have no effect and the associated services will be reported as "masked". However, if the referenced unit files should be re-installed again, the symlinks will resume their former function.

Services (and 'units' generally ) can be enabled/disabled/reenabled and started/stopped/restarted.

Enabling and disabling just means to define whether units will be started or stopped when the system starts up of when runlevels are changed. They do not immediately start or stop a service/unit. But both can be combined when `--now` is used:

----
$ systemctl disable --now bluetooth
----

This makes the 'enable' and 'disable' sub-commands also implicitly execute 'start' and 'stop', respectively.

The 'reenable'- and 'restart'-commands are just macros which execute 'stop' and 'start' or 'disable' and 'enable' in that order, respectively.

The question remains into what run-levels/targets 'enable' will symlink a unit, and from which tartgets 'disable' will remove those symlinks.

This is controlled by the `[Install]`-sections of the unit files, where typically the `WantedBy`-Property specifies a list of targets which shall contain this unit by default.

Which targets have a unit enabled or disables can then be modified by overriding those properties.

Another and most likely simpler way is to add or remove the symlinks in the `*.target-wants`-directories directly. Systemd will honor those settings. However, the 'disable' command may remove those symlinks, so the overriding method is more permanent.

There is also a 'preset'-subcommand which resets the enable/disable status of a unit to its preset. However, like the `enable`/`disable` sub-commands themselves, this is not runlevel-specific but depend on the `WantedBy`-properties (and their overrides).

Whether a unit is enabled or disabled by default may be specified in the unit file itself (the default setting), but customized `/etc/systemd/system-preset/*.preset` files installed by the administrator may override this default. Installing such `*.preset`-files enable the administrator to disable unwanted services an many hosts by just copying those files.

Summing up, the recommended way to deal with runlevel assignments of services is creating `*preset`-files for services generally not wanted in any runlevel, and creating override files for `WantedBy`-properties in `*.d`-directories associated with the service for which to customize its run-level associations.


Overriding factory presets
--------------------------

First of all, it is possible to place a custom-written 'unit' file somewhere below `/etc/systemd` which replaces or extends the functionality of existing units.

But most of the time it is simpler to create a snippet-directory containing configuration files with settings that override particular setting of the existing unit files.

For instance, if there is a unit file (or symlink) `/etc/systemd/system/rc.local.service`, then any snippet files `/etc/systemd/system/rc.local.service.d/*.conf` will be read and can override specific properties of the unit file.

The snippet file have the same syntax as regular unit files, but they only need to define what shall be overriden and leave out the rest.


Home Directories
----------------

`systemd-homed` may be used to dynamically create and destroy home directories.

The UID range `60001-60513` is reserved for that purpose.


Dynamic Users
-------------

Systemd can dynamically allocate a UNIX user ID for service processes when it starts them and release it when it stops them.

The UID range 61184-65519 (0xEF00–0xFFEF) is reserved for this purpose.

This range has been chosen because distributions (specifically Fedora) tend to allocate regular users from below the 60000 range, and we don't want to step into that. We also want to stay away from 65535 and a bit around it, as some of these UIDs have special meanings (65535 is often used as special value for "invalid" or "no" UID, as it is identical to the 16bit value -1; 65534 is generally mapped to the "nobody" user, and is where some kernel subsystems map unmappable UIDs). Finally, we want to stay within the 16bit range. Within containers, the the higher 16bit of the 32bit UID values this way become a container ID, while the lower 16bit become the logical UID within each container.
