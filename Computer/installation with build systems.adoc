Build/Install
=============
v2025.42

How to build and install the unpacked sources in the current directory.


"debian"-subdirectory present
-----------------------------

A staging directory is not needed. Instead, a *.deb package is built, which will then be installed.

----
$ b=`mktemp -dp .` && cp -R -P -p -- * "$b" || true && cd -- "$b" && command -v debuild > /dev/null || sudo apt-get install devscripts
$ debuild -us -uc # Avoid signing.
$ debuild --no-lintian -us -uc # Use instead if problems with lintian.
$ cd .. && test "`ls *.deb | wc -l`" = 1 || echo 'did not build one package!'
$ rm -r -- "$b" && unset b
$ sudo dpkg -i -- *.deb || sudo apt-get install -f
----


Via a staging directory
-----------------------

Prepare
~~~~~~~

Select the name of the staging subdirectory; this will also be the logical name of the package. That name typically includes a version number.

----
$ subdir=`basename \`pwd\`` # Normal case.
$ subdir='any name you like' # Override.
----


Install prerequisites under Debian 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In case that run-time dependencies required by the package to be installed can be installed as regular Debian-packages, create and install a dependency pseudo-package first:

----
$ deps='dep1, dep2preferred | dep2alternative, dep3'; expr x"$deps" : x'[^,| ]\{1,\}\( *[,|] *[^,| ]\{1,\}\)*$' > /dev/null || echo 'INVALID dependencies!'
$ dp=$subdir-`dd if=/dev/urandom bs=1 count=\`expr 103 / 8\` 2> /dev/null | od -A n -t x1 | tr -dc '[:xdigit:]'` && dp=$dp && echo "Dependency package for $subdir: $dp"
$ cf=`mktemp -p .` && command -v equivs-control > /dev/null 2>& 1 || sudo apt-get install equivs && equivs-control "$cf"
$ sed -i 's/^\(Package: \).*/\1/; t pn; s/^\(Description: \).*/\1/; t pd; s/^# \(Depends: \).*/\1/; t deps; s/^ .*//; b; :pn; s/$/'"$dp"'/; b; :pd; s/$/Dependencies for manually-installed package '"$subdir"'/; b; :deps; s/$/'"$deps"'/' "$cf" && unset deps
$ equivs-build "$cf" && rm -- "$cf" && unset cf
$ sudo dpkg -i -- "`ls -t1 -- *.deb | head -n 1`" || sudo apt-get install -f
----


Preinstall
~~~~~~~~~~

This step will install the package contents into the chosen staging subdirectory.


make/automake
^^^^^^^^^^^^^
----
$ cf='-O2 -DNDEBUG -pipe -march=native -fno-stack-protector -fomit-frame-pointer -fno-stack-check -s -Wl,-O1,--as-needed,--hash-style=gnu' # For small executables which are not security-critical. Use -O3 if speed is most important.
$ { make --version 2> /dev/null | grep -q GNU && mf=`getconf _NPROCESSORS_ONLN 2> /dev/null` && test $mf != 1 && mf=`expr $mf + 1` && mf=" -j $mf -l $mf"; } || mf=
$ make$mf CFLAGS="$cf" CXXFLAGS="$cf" && unset cf mf # Try again with $mf set to an empty string if there was a build problem.
$ make install DESTDIR="`pwd`/$subdir"
----


setup.py
^^^^^^^^
----
$ python setup.py install --root="`pwd`/$subdir"
----


cmake
^^^^^

Run this from the base directory of the source tree:

----
$ pn=llvm pv=16.0.2 finaldest=$HOME/.local
$ ionice -n6 nice cmake -G Ninja -S llvm -B build -D CMAKE_BUILD_TYPE=Release -D CMAKE_INSTALL_PREFIX="${finaldest:?}" -D LLVM_ENABLE_PROJECTS='bolt;clang;clang-tools-extra;compiler-rt;libc;libclc;lld;lldb;mlir;openmp;polly;pstl;flang' -D LLVM_ENABLE_RUNTIMES='libcxx;libcxxabi;libunwind'
$ cd build
$ pjobs=`nproc`; pjobs=`expr $pjobs + 1`
$ ninja edit_cache
$ ionice -n6 nice cmake --build . -- -j${pjobs:?} -l${pjobs:?}
$ ionice -n6 nice cmake --install . --prefix "stage/${pn:?}-${pv:?}/${finaldest:?}"
----

Normally the `cmake` build definition file "`CMakeLists.txt`" is also in the base directory. However, in the example above, it was in a "`llvm`"-subdirectory of the base directory. This is why the option "`-S llvm`" has been added to help `cmake` locate the build definition file.

`cmake` does not want to pollute the source directory with the files generated by the build process. It therefore requires the user to specify a build directory where the generated files shall be written to. This is the "`build`" argument in the examples. In this case, it is a relative path to the source base directory. However the build directory, it could also be any other relative or even an absolute path. Neither does it need to be called "`build`". Any name will do.

In the above example we chose the `Ninja`-backend for `cmake`. That is the argument of the "`-G`" option. Without this option, `cmake` used the local platform's default build mechanism (typically "`make`"). Both backends work, but if "`ninja`" is installed it should be preferred as it is slightly faster than "`make`" and has a prettier progress indicator.

Also note that the options after "`cmake --build build --`" are passed to the actual build tool, which can be "`make`" or "`ninja`". Luckily, both tools (at least if using the GNU implementation of "`make`") support the "`-j`" and "`-l`" options, so it works the same with "`-G Ninja`" or without it. However, one is not always this lucky. `cmake` supports more backends than just "`make`" and "`ninja`", and those other backends might not understand the options after "`--`" from the example above.

The `cmake` variable `CMAKE_INSTALL_PREFIX` defines the base directory where the application should eventually be installed to (from where it will run after it has been installed). Defaults to "`/usr/local`". In the above example, this has been changed to install for the current user only rather than a system-wide installation.

The "`--prefix`"-option of the "`cmake --install`"-command allows to temporarily override the installation destination. The example uses this to install the files into a temporary staging directory rather than into its actual destination. This allows to package the files in the staging directory using a package manager. The files will then be installed into their final destination by that package manager, rather than directly via "`cmake --install`" itself. The example installs the files into staging directory "`build/stages/$pn-$pv`" relative to the current directory. This directory represents the virtual root for the filesystem into which the files shall be installed later by the package manager.

If you actually *want* to install the files directly to their final destination, just omit the "`--prefix`"-option.

Note that the build directory is an argument of the "`--install`"-option. This is why more arguments are allowed to follow after that option.

Also note that `cmake` does not like "`=`" between a long option and its argument - except for the "`-D`" option as shown above which is used to define or override `cmake` variables on the command line. List items within list-arguments must be separated by semicolons ("`;`").


Variables influencing Makefile backends
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If some build system uses `make` as its backend, the following exported environment variables can be set to influence it:

----
$ jobs=`getconf _NPROCESSORS_ONLN || echo 1` && jobs=`expr $jobs + 1`
$ export CFLAGS='-D NDEBUG -pipe -O3 -mtune=native'
$ export CXXFLAGS='-D NDEBUG -pipe -O3 -mtune=native'
$ export LDFLAGS='-s -Wl,-O1 -Wl,--as-needed -Wl,--hash-style=gnu'
$ export MAKEFLAGS="-e -l${jobs:?} -j${jobs:?}"
$ unset CPPFLAGS jobs
----

Note that `CPPFLAGS` is unset. Event though 'GNU automake' does honor `CPPFLAGS`, POSIX doesn't and therefore setting `CPPFLAGS` for a Makefile is unreliable.

It is more portable to duplicate macro definitions within `CFLAGS` and `CXXFLAGS` rather than avoid the duplication and just use `CPPFLAGS` for macro definitions.

Also note that the above variables also seem to influence `cmake` directly on invocation, because the settings are also used with the Ninja backend of `cmake` which does not used those variables directly.

Examine which of the above variables are currently defined with:

----
$ env | grep FLAGS
----

You might want to unset alle variables in order to make sure they cannot affect the current build:

----
$ unset CFLAGS CPPFLAGS CXXFLAGS LDFLAGS MAKEFLAGS
----


Without build support for installation
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If the Makefile does not provide an "install" target, or if there is no Makefile at all but just some script which builds the binaries and man pages, the following can be attempted to populate the staging dir:

----
$ ipfx=/usr/local # Installation prefix to use when actually installing later; modify if necessary.
$ find -type f | xargs file -i -- | grep -E '[^:]+: *(application/x-executable)(;.*)*$' | cut -d : -f 1 | while IFS= read -r f; do d=$subdir/${ipfx##/}/bin && test -d "$d" || mkdir -p -- "$d" && cp -p -- "$f" "$d"/; done
----

Manual inspection and possible custom adaption is recommended.


Install from stage
~~~~~~~~~~~~~~~~~~

This step actually performs the installation from the already-populated staging directory "`$subdir`" using a helper script "`package-manager-for-the-poor`" which also records the necessary information for later uninstallation.

----
$ sudo chown -R root:root "$subdir" && sudo sh -lc "package-manager-for-the-poor -i \"$subdir\"" && sudo rm -r -- "$subdir"
----

In this case, the basename of "`$subdir`" will be used as the packages' installation name. It should therefore be made at least of the package name, preferably also the package version, and optionally also the target architecture (on 'multilib' systems which might install the same package version for multiple different sub-architectures such as  "`i386`" and "`amd64`").


imake
~~~~~

This type of project is suggested when a a source archive is shipped with an "Imakefile" instead of a "Makefile". imake is not intended to be invoked directly, but rather via the helper utility xmkmf.

----
$ command -v imake > /dev/null 2>& 1 || sudo apt-get install xutils-dev
$ xmkmf
$ make depend
$ make
$ make install DESTDIR=$staging_dir
----

I could not yet find a reliable way to define an installation prefix like `--prefix` does with `automake`.


qmake
~~~~~

----
$ cd $sourcedir
$ grep -F .path *.pro # Review installation paths, notably "target.path"
$ qmake # uses the *.pro file, add "-set" options if necessary
$ { make --version 2> /dev/null | grep -q GNU && mf=`getconf _NPROCESSORS_ONLN 2> /dev/null` && test $mf != 1 && mf=`expr $mf + 1` && mf=" -j $mf -l $mf"; } || mf=
$ make $mf
$ make install INSTALL_ROOT=$staging_dir
----

One problem of some qmake project files are fixed installation paths. In this case, the project file needs to be patched.

----
$ oprj=`ls *.pro | grep -v 'patched\.pro$'`
$ nprj=${oprj%.pro}-patched.pro
$ sed "s|/usr/|$HOME/.local/|g" "${oprj:?}" > "${nprj:?}"
$ diff -u "${oprj:?}" "${nprj:?}" | less
$ qmake "$nprj"
----

Also examine the generated `Makefile`. Find for the `install:` target and look out for an environment variable such as `$INSTALL_ROOT` which can be set to override the installation base directory in a similar way many other Makefiles support `$DESTDIR` for specifying a staging directory.

In other cases, the installation is made dependent on a single variable sometimes named `PREFIX` which is indicated in the project file by a line such as

....
target.path = $$[PREFIX]
....

In such cases, `PREFIX` is a special `qmake` 'property' which can be set/overridden when `qmake` is invoked like this:

----
$ qmake -set PREFIX "$HOME"/.local
----
